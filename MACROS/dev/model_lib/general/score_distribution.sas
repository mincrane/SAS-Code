/* ***********************************************************************************************
* Macro for creating the baseline for population stability calculations
* Parameters involved:

					DATASET -- complete path of the dataset for which the baseline statistics
										 are to be drawn.
					_VAR     -- the score variable.
					BREAKS   -- No. of breaks in the score distribution
					weight_var  -- weight variable
					BAD_FLAG  -- Name of the performance variable
					FORMATFILENAME -- Name of the file containing the proc format statement.Defaults to fmtname.sas
					FORMATNAME -- Name of the format generated by the proc format statement.Defaults to fmtname.
					GEN_OPT -- option to generate new percentile ranges. Defaults to YES
					WHERE  -- condition to subset the data set
					
					Sample macro call: 
					%score_dist(
								dataset=temp.existing_analysis_total,
								_var=probability,
								breaks=20,
								weight_var=,
								bad_flag=perf_flag1_d90,
								formatfilename=test_format.sas,
								fmtname=fmtname,
								gen_opt=yes,
								where=,
								event=0,
								non_event=1,
								eventlabel=Good,
								noneventlabel=Bad
							  );
	*Creates a temporary dataset - work.score_dist1. USer has to print this dataset to view results
***********************************************************************************************/

		%macro score_dist(
										dataset=,
										_var=,
										breaks=,
										weight_var=,
										bad_flag=,
										formatfilename=fmtname.sas,
										fmtname=fmtname,
										gen_opt=yes,
										where=,
										event=0,
										non_event=1,
										eventlabel=Good,
										noneventlabel=Bad
									  );
		
		%let partsize= %sysevalf( 100 / &breaks );
		%local epsilon;
		%let epsilon= 1e-10;
		%global breaks1;
		%let breaks1 = &breaks.;
			
			data dset;
				set &dataset.(keep=&_var. %IF %length(&weight_var.) > 0 %THEN %DO;
			                                &weight_var.
			                                %END; &bad_flag.
			                 );
				acc=&bad_flag.;
				cntr=1;
				%IF %length(&where.) > 0 %THEN %DO;
					where &where.;
				%END;
			run;
			
	%IF %upcase(&gen_opt.)=YES %THEN %DO;

		proc univariate data=dset noprint;
			var &_var.;
			%IF %length(&weight_var.) > 0 %THEN %DO;
			weight &weight_var.;
			%END;
			output out=_univ pctlpre= P pctlpts= 0 to 100 by &partsize.;
		run;

		data cuts1;
			set _univ;
			array p[*] P0 -- P100;
			do i=1 to dim(p)-1;
				brk= i;
				lo= p[i];
				hi= p[i+1];
				output;
			end;
			keep brk lo hi;
		run;
			
			*drop degenerate groups;
		proc sort data=cuts1;
			by lo hi;
		run;
			
		data cuts1;
			set cuts1;
			by lo;
			if last.lo then output;
		run;
		
		/* Added on 12/06/2011 */
		data _null_;
		    set cuts1 nobs=nobs; ;
		    FILE "&formatfilename.";
		    
		    if _n_=1 THEN DO;
		            put "proc format;";
		            put "value &fmtname."; 
		            put "       LOW -< " hi "=" " 'LOW -< " hi"'";
		    end;
		    else if _n_ ne 1 and _n_ ne nobs THEN DO;
		            put "       " lo " -< " hi "=" " '" lo " -< " hi"'";
		    end;
		    
		    else if _n_=nobs THEN DO;
		            put "       " lo " - HIGH =" " '" lo " - HIGH' ;";
		            put "run;";
		    end;
		run;
		
	%END;

    %include "&formatfilename.";
    
    proc means data=dset noprint;
        class &_var.;
        var cntr;
        %IF %length(&weight_var.) > 0 %THEN %DO;
            weight &weight_var.;
        %END;
        format &_var. &fmtname..;
        output out=_means_tot sumwgt=no_of_acc;
    run;
    
    proc means data=dset(where=(acc=&event.)) noprint;
        class &_var.;
        var cntr;
        %IF %length(&weight_var.) > 0 %THEN %DO;
            weight &weight_var.;
        %END;
        format &_var. &fmtname..;
        output out=_means_event sumwgt=event_acc;
    run;
    
    data _means_tot;
        set _means_tot;
    run;
    
    data _means_event;
        set _means_event;
    run;
    /*
    proc sql;
		create table _means as
		select a.&_var., a.no_of_acc, b.event_acc
		from _means_tot as a
		left outer join
		     _means_event as b
		on a.rownum=b.rownum;
	quit;
	*/
	data _means;
	    merge _means_tot   (keep=&_var. no_of_acc) 
	          _means_event (keep= event_acc) ;
	run;

    
    data score_dist;
        set _means;
        non_event_acc=no_of_acc - event_acc;
        
        retain tot_event;
        if &_var=. then tot_event = event_acc;
        
        retain tot_non_event;
        if &_var=. then tot_non_event = non_event_acc;
        
        percent_event= event_acc/tot_event;
        percent_non_event = non_event_acc/tot_non_event;
        drop tot_non_event tot_event;
        
        delta= percent_event - percent_non_event;
        woe= log(sum(percent_event,&epsilon.)/sum(percent_non_event,&epsilon.));
        iv= delta*woe;
    run;
    
    data score_dist1;
        set score_dist;
        
        retain cum_event;
        retain cum_non_event;
        
        cum_event=sum(percent_event,cum_event);
        cum_non_event=sum(percent_non_event,cum_non_event);
        
        ks_spread = abs(cum_non_event - cum_event)*100;
        where &_var. ne .;
	    run;
	    
	    %global max_ks;
		
		proc sql noprint;	
			select max(abs(ks_spread))
			into :max_ks
			from score_dist1;
		quit;
		
		data score_dist1;
			set score_dist1;
			label &_var.="Score Range" no_of_acc= "Total # of Accounts" event_acc= "# of &eventlabel. Accounts"
				  non_event_acc= "# of &noneventlabel. Accounts" percent_event= "% of &eventlabel. Accounts" percent_non_event= "% of &noneventlabel. Accounts" delta= "Difference in %"
				  woe= "Weight of Evidence" cum_non_event= "Cumulative % of &noneventlabel. Accounts" cum_event= "Cumulative % of &eventlabel. Accounts" iv= "Information Value" ks_spread ="KS Spread";
			format percent_event percent_non_event cum_event cum_non_event percent10.1
				   no_of_acc event_acc non_event_acc comma10.0
				   ks_spread comma10.1 iv comma10.4;
		run;
	
		%mend score_dist;
       